#include <opencv2/opencv.hpp>
#include "opencv2/core/core.hpp"
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <opencv2/ml/ml.hpp>
#include <boost/filesystem.hpp>
#include <string.h>
#include "Config.h"
#include<iostream>
using namespace cv;
using namespace std;
using namespace boost::filesystem3;

#ifndef CLASSIFIER_H
#define CLASSIFIER_H
 
class classifier {
private:
map<string, Mat> templates, objects, positive_data, negative_data; //category to inf
multimap<string, Mat> train_set; //category to training images
map<string, CvSVM> svms;//category to svm
vector<string> category_names;//category
int categories;
int clusters;//number of clusters for SURF features to build vocabulary
Mat vocab;
Ptr<FeatureDetector> featureDetector;
Ptr<DescriptorExtractor> descriptorExtractor;
Ptr<BOWKMeansTrainer> bowtrainer;
Ptr<BOWImgDescriptorExtractor> bowDescriptorExtractor;
Ptr<DescriptorMatcher> descriptorMatcher;
 
void make_train_set(int);
void make_pos_neg();
string remove_extension(string);
public:classifier(int,int); 
void build_vocab();
void train_classifiers();
string categorize(Mat);
void read_vocab();
};
 
void classifier::read_vocab()
{
int i;
string str2="my_svm";
FileStorage f1("/var/www/code/data/vocab.xml", FileStorage::READ);
f1["vocabulary"] >> vocab;
f1.release();
for(i=0;i<category_names.size();i++)
 {
string name=string("/var/www/code/data/")+category_names[i]+string("SVM.xml");
svms[category_names[i]].load(name.c_str());
 }
}

string classifier::remove_extension(string full) {
int last_idx = full.find_last_of(".");
string name = full.substr(0, last_idx);
return name;
}
 
classifier::classifier(int _clusters,int k) { 
clusters = _clusters;
featureDetector = (new SiftFeatureDetector());
descriptorExtractor = (new SiftDescriptorExtractor());
bowtrainer = (new BOWKMeansTrainer(clusters));
descriptorMatcher = (new FlannBasedMatcher());
bowDescriptorExtractor = (new BOWImgDescriptorExtractor(descriptorExtractor,descriptorMatcher));
#pragma omp parallel_for
for(directory_iterator i("/var/www/code/data/templates/"), end_iter; i != end_iter; i++) {
string filename = string("/var/www/code/data/templates/") + i->path().filename().string();
string category = remove_extension(i->path().filename().string());
Mat im = imread(filename);
objects[category] = im;
//cvtColor(im, templ_im, CV_BGR2GRAY);
templates[category] = im;
}
make_train_set(k);
}
 
void classifier::make_train_set(int k) {
string category;
#pragma omp parallel_for
for(recursive_directory_iterator i("/var/www/code/data/train_images/"), end_iter; i != end_iter; i++) {
if(i.level() == 0) {
// Get category names
category = (i -> path()).filename().string();
category_names.push_back(category);
}
else {
// if testing
if(k==0) 
continue;
// else testing
string filename = string("/var/www/code/data/train_images/") + category + string("/") +(i -> path()).filename().string();
pair<string, Mat> p(category, imread(filename, CV_LOAD_IMAGE_GRAYSCALE));
train_set.insert(p);
}
}
categories = category_names.size();
}
 
void classifier::make_pos_neg() {
for(multimap<string, Mat>::iterator i = train_set.begin(); i != train_set.end(); i++) {
string category = (*i).first;// <string,
Mat im = (*i).second;// Mat>
Mat feat; 

vector<KeyPoint> kp;
featureDetector -> detect(im, kp);
bowDescriptorExtractor -> compute(im, kp, feat);
 
// Mats to hold the positive and negative training data for current category
Mat pos, neg;
#pragma omp parallel_for
for(int cat_index = 0; cat_index < categories; cat_index++) {
string check_category = category_names[cat_index];
if(check_category.compare(category) == 0)
positive_data[check_category].push_back(feat);
else
negative_data[check_category].push_back(feat);
}
}
}

void classifier::build_vocab() { 
Mat vocab_descriptors; //descriptors
#pragma omp parallel_for
for(map<string, Mat>::iterator i = templates.begin(); i != templates.end(); i++) {
vector<KeyPoint> kp; Mat templ = (*i).second, desc;
featureDetector -> detect(templ, kp);
descriptorExtractor -> compute(templ, kp, desc);
vocab_descriptors.push_back(desc);
}
 
bowtrainer -> add(vocab_descriptors);

vocab = bowtrainer->cluster();
 
FileStorage fs("/var/www/code/data/vocab.xml", FileStorage::WRITE);
fs << "vocabulary" << vocab;
fs.release();
 
}
 
void classifier::train_classifiers() {
bowDescriptorExtractor -> setVocabulary(vocab);
make_pos_neg();
 for(int i = 0; i < categories; i++) {
string category = category_names[i];
 
Mat train_data = positive_data[category], train_labels = Mat::ones(train_data.rows, 1, CV_32S); //+ve means 1
train_data.push_back(negative_data[category]);// negative means 0
Mat m = Mat::zeros(negative_data[category].rows, 1, CV_32S);  
train_labels.push_back(m);// in +ve adding -ve
 
svms[category].train(train_data, train_labels);
 
string svm_filename =string("/var/www/code/data/")+category + string("SVM.xml");
svms[category].save(svm_filename.c_str());
}
 
}

string classifier::categorize(Mat cap) {
string predicted_category="";
bowDescriptorExtractor -> setVocabulary(vocab);
//cvtColor(cap, frame_g, CV_BGR2GRAY);
vector<KeyPoint> kp;
Mat test11;
featureDetector -> detect(cap,kp);
bowDescriptorExtractor -> compute(cap,kp,test11);
float best_score = 777;
for(int i = 0; i < categories; i++) {
string category = category_names[i];
float prediction = svms[category].predict(test11, true);
if(prediction < best_score) {
best_score = prediction;
predicted_category = category;
}
}
return predicted_category;
}

#endif
